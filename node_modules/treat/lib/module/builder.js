var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
import { fromPairs, isEqual } from 'lodash';
import dedent from 'dedent';
import { stringify } from 'javascript-stringify';
import { makeThemedClassReference, convertToCssClass, templateThemeClassRef, } from './utils';
import { createContentHash } from './createContentHash';
import { processSelectors, addLocalClassRef, interpolateSelector, isThemedSelector, } from './processSelectors';
import { validateStyle, validateGlobalStyle } from './validator';
import { addLocalCss, addThemedCss, addTheme, getThemes, getIdentName, getNextScope, } from './webpackTreat';
var createKeyframe = function (keyframe, themeRef) {
    var _a;
    if (typeof keyframe === 'string') {
        return keyframe;
    }
    var keyframeRef = createContentHash(keyframe);
    var keyframeBlock = (_a = {},
        _a["@keyframes " + keyframeRef] = keyframe,
        _a);
    if (themeRef) {
        addThemedCss(themeRef, keyframeBlock);
    }
    else {
        addLocalCss(keyframeBlock);
    }
    return keyframeRef;
};
var processAnimations = function (style, themeRef) {
    // handle root level keyframes
    if (style['@keyframes']) {
        style['@keyframes'] = createKeyframe(style['@keyframes'], themeRef);
    }
    var media = style['@media'];
    // handle keyframes in media queries
    if (media) {
        Object.keys(media).forEach(function (mediaQuery) {
            processAnimations(media[mediaQuery]);
        });
    }
    // handle keyframes in simple pseudos
    Object.entries(style)
        .filter(function (_a) {
        var property = _a[0];
        return property.startsWith(':');
    })
        .forEach(function (_a) {
        var _pseudoProperty = _a[0], pseudoStyle = _a[1];
        if (pseudoStyle['@keyframes']) {
            pseudoStyle['@keyframes'] = createKeyframe(pseudoStyle['@keyframes'], themeRef);
        }
    });
    // handle keyframes in complex selectors
    if (style.selectors) {
        Object.values(style.selectors).forEach(function (selectorStyle) {
            if (selectorStyle['@keyframes']) {
                selectorStyle['@keyframes'] = createKeyframe(selectorStyle['@keyframes'], themeRef);
            }
        });
    }
};
var processStyle = function (style, themeRef) {
    processSelectors({ style: style, themeRef: themeRef, themes: getThemes() });
    processAnimations(style, themeRef);
};
var createThemedCss = function (classRef, style) {
    Object.entries(style).forEach(function (_a) {
        var _b;
        var themeRef = _a[0], themeStyle = _a[1];
        validateStyle(themeStyle);
        processStyle(themeStyle, themeRef);
        var themedClassRef = makeThemedClassReference(themeRef, classRef);
        addThemedCss(themeRef, (_b = {},
            _b[convertToCssClass(themedClassRef)] = themeStyle,
            _b));
    });
    return templateThemeClassRef(classRef);
};
export function style(style, localDebugName) {
    var _a;
    var localName = localDebugName || 'style';
    var classRef = getIdentName(localName, getNextScope());
    if (typeof style === 'object') {
        validateStyle(style);
        addLocalClassRef(classRef);
        processStyle(style);
        addLocalCss((_a = {}, _a[convertToCssClass(classRef)] = style, _a));
        return classRef;
    }
    else {
        var themedStyle = Object.assign.apply(Object, [{}].concat(getThemes().map(function (_a) {
            var _b;
            var themeRef = _a.themeRef, tokens = _a.tokens;
            var themedStyle = style(tokens);
            validateStyle(themedStyle);
            return _b = {},
                _b[themeRef] = themedStyle,
                _b;
        })));
        return createThemedCss(classRef, themedStyle);
    }
}
export function styleMap(stylesheet, localDebugName) {
    var classRefs = {};
    var createLocalName = function (classIdentifier) {
        if (localDebugName) {
            return localDebugName + "_" + classIdentifier;
        }
        return classIdentifier;
    };
    if (typeof stylesheet === 'function') {
        var styleMap_1 = new Map();
        getThemes().forEach(function (_a) {
            var themeRef = _a.themeRef, tokens = _a.tokens;
            var themedStyles = stylesheet(tokens);
            Object.entries(themedStyles).forEach(function (_a) {
                var _b;
                var classIdent = _a[0], style = _a[1];
                var styleMapValue = styleMap_1.get(classIdent) || {};
                styleMap_1.set(classIdent, Object.assign({}, styleMapValue, (_b = {}, _b[themeRef] = style, _b)));
            });
        });
        Array.from(styleMap_1.entries()).forEach(function (_a) {
            var classIdent = _a[0], styles = _a[1];
            var classRef = getIdentName(createLocalName(classIdent), getNextScope());
            classRefs[classIdent] = createThemedCss(classRef, styles);
        });
    }
    else {
        var postCss = fromPairs(Object.entries(stylesheet).map(function (_a) {
            var classIdentifier = _a[0], style = _a[1];
            validateStyle(style);
            var classRef = getIdentName(createLocalName(classIdentifier), getNextScope());
            classRefs[classIdentifier] = classRef;
            addLocalClassRef(classRef);
            processStyle(style);
            return [convertToCssClass(classRef), style];
        }));
        addLocalCss(postCss);
    }
    return classRefs;
}
export function createTheme(tokens, localDebugName) {
    var theme = {
        themeRef: getIdentName(localDebugName || 'theme', getNextScope(), tokens),
        tokens: tokens,
    };
    addTheme(theme);
    return theme.themeRef;
}
export function globalStyle(selector, style) {
    var _a;
    if (isThemedSelector(selector)) {
        getThemes().forEach(function (theme) {
            var _a;
            var themedSelector = interpolateSelector(selector, theme.themeRef);
            var themeStyle = typeof style === 'function' ? style(theme.tokens) : style;
            validateGlobalStyle(themeStyle);
            addThemedCss(theme.themeRef, (_a = {}, _a[themedSelector] = themeStyle, _a));
        });
    }
    else {
        var normalisedSelector = interpolateSelector(selector);
        if (typeof style === 'function') {
            throw Error(dedent(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          Unthemeable selector: ", "\n          \n          Global styles cannot be themed unless the selector references a themed class.\n          \n          For example, you could add a themed class to the start of your selector (e.g. ", ").\n          \n          Without a reference to a themed class, there is no way to selectively apply styles based on the current theme.\n        "], ["\n          Unthemeable selector: ", "\n          \n          Global styles cannot be themed unless the selector references a themed class.\n          \n          For example, you could add a themed class to the start of your selector (e.g. ", ").\n          \n          Without a reference to a themed class, there is no way to selectively apply styles based on the current theme.\n        "])), normalisedSelector, '`${themedClass} h1`'));
        }
        validateGlobalStyle(style);
        processAnimations(style);
        addLocalCss((_a = {}, _a[normalisedSelector] = style, _a));
    }
}
export function styleTree(makeStyleTree) {
    var themedClassRefs = new Map();
    var assignedScopes = [];
    var getNodeScope = function (scopeIndex) {
        if (typeof assignedScopes[scopeIndex] !== 'number') {
            assignedScopes[scopeIndex] = getNextScope();
        }
        return assignedScopes[scopeIndex];
    };
    var themedTrees = getThemes().map(function (_a) {
        var tokens = _a.tokens, themeRef = _a.themeRef;
        var scopeIndex = 0;
        var makeStyle = function (style, localDebugName) {
            var _a;
            var localName = localDebugName || 'styleNode';
            var classRef = getIdentName(localName, getNodeScope(scopeIndex++));
            var themedClassRefValue = themedClassRefs.get(classRef) || {};
            validateStyle(style);
            themedClassRefs.set(classRef, Object.assign({}, themedClassRefValue, (_a = {}, _a[themeRef] = style, _a)));
            return templateThemeClassRef(classRef);
        };
        return makeStyleTree(tokens, makeStyle);
    });
    var referenceTree = themedTrees[0], restTrees = themedTrees.slice(1);
    restTrees.forEach(function (tree) {
        if (!isEqual(tree, referenceTree)) {
            throw new Error(dedent(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n        Mismatching style trees.\n\n        All 'styleTree' functions must return the same structure for every theme.\n        \n        To avoid this error, ensure that object keys and array lengths do not depend on unique properties of each theme.\n        \n        Expected:\n        \n        ", "\n\n        Received:\n        \n        ", "\n      "], ["\n        Mismatching style trees.\n\n        All 'styleTree' functions must return the same structure for every theme.\n        \n        To avoid this error, ensure that object keys and array lengths do not depend on unique properties of each theme.\n        \n        Expected:\n        \n        ", "\n\n        Received:\n        \n        ", "\n      "])), stringify(referenceTree, null, 2), stringify(tree, null, 2)));
        }
    });
    Array.from(themedClassRefs.entries()).forEach(function (_a) {
        var classRef = _a[0], styles = _a[1];
        createThemedCss(classRef, styles);
    });
    return referenceTree;
}
var templateObject_1, templateObject_2;
