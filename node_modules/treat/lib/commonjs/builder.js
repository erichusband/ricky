"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var dedent_1 = __importDefault(require("dedent"));
var javascript_stringify_1 = require("javascript-stringify");
var utils_1 = require("./utils");
var createContentHash_1 = require("./createContentHash");
var processSelectors_1 = require("./processSelectors");
var validator_1 = require("./validator");
var webpackTreat_1 = require("./webpackTreat");
var createKeyframe = function (keyframe, themeRef) {
    var _a;
    if (typeof keyframe === 'string') {
        return keyframe;
    }
    var keyframeRef = createContentHash_1.createContentHash(keyframe);
    var keyframeBlock = (_a = {},
        _a["@keyframes " + keyframeRef] = keyframe,
        _a);
    if (themeRef) {
        webpackTreat_1.addThemedCss(themeRef, keyframeBlock);
    }
    else {
        webpackTreat_1.addLocalCss(keyframeBlock);
    }
    return keyframeRef;
};
var processAnimations = function (style, themeRef) {
    // handle root level keyframes
    if (style['@keyframes']) {
        style['@keyframes'] = createKeyframe(style['@keyframes'], themeRef);
    }
    var media = style['@media'];
    // handle keyframes in media queries
    if (media) {
        Object.keys(media).forEach(function (mediaQuery) {
            processAnimations(media[mediaQuery]);
        });
    }
    // handle keyframes in simple pseudos
    Object.entries(style)
        .filter(function (_a) {
        var property = _a[0];
        return property.startsWith(':');
    })
        .forEach(function (_a) {
        var _pseudoProperty = _a[0], pseudoStyle = _a[1];
        if (pseudoStyle['@keyframes']) {
            pseudoStyle['@keyframes'] = createKeyframe(pseudoStyle['@keyframes'], themeRef);
        }
    });
    // handle keyframes in complex selectors
    if (style.selectors) {
        Object.values(style.selectors).forEach(function (selectorStyle) {
            if (selectorStyle['@keyframes']) {
                selectorStyle['@keyframes'] = createKeyframe(selectorStyle['@keyframes'], themeRef);
            }
        });
    }
};
var processStyle = function (style, themeRef) {
    processSelectors_1.processSelectors({ style: style, themeRef: themeRef, themes: webpackTreat_1.getThemes() });
    processAnimations(style, themeRef);
};
var createThemedCss = function (classRef, style) {
    Object.entries(style).forEach(function (_a) {
        var _b;
        var themeRef = _a[0], themeStyle = _a[1];
        validator_1.validateStyle(themeStyle);
        processStyle(themeStyle, themeRef);
        var themedClassRef = utils_1.makeThemedClassReference(themeRef, classRef);
        webpackTreat_1.addThemedCss(themeRef, (_b = {},
            _b[utils_1.convertToCssClass(themedClassRef)] = themeStyle,
            _b));
    });
    return utils_1.templateThemeClassRef(classRef);
};
function style(style, localDebugName) {
    var _a;
    var localName = localDebugName || 'style';
    var classRef = webpackTreat_1.getIdentName(localName, webpackTreat_1.getNextScope());
    if (typeof style === 'object') {
        validator_1.validateStyle(style);
        processSelectors_1.addLocalClassRef(classRef);
        processStyle(style);
        webpackTreat_1.addLocalCss((_a = {}, _a[utils_1.convertToCssClass(classRef)] = style, _a));
        return classRef;
    }
    else {
        var themedStyle = Object.assign.apply(Object, [{}].concat(webpackTreat_1.getThemes().map(function (_a) {
            var _b;
            var themeRef = _a.themeRef, tokens = _a.tokens;
            var themedStyle = style(tokens);
            validator_1.validateStyle(themedStyle);
            return _b = {},
                _b[themeRef] = themedStyle,
                _b;
        })));
        return createThemedCss(classRef, themedStyle);
    }
}
exports.style = style;
function styleMap(stylesheet, localDebugName) {
    var classRefs = {};
    var createLocalName = function (classIdentifier) {
        if (localDebugName) {
            return localDebugName + "_" + classIdentifier;
        }
        return classIdentifier;
    };
    if (typeof stylesheet === 'function') {
        var styleMap_1 = new Map();
        webpackTreat_1.getThemes().forEach(function (_a) {
            var themeRef = _a.themeRef, tokens = _a.tokens;
            var themedStyles = stylesheet(tokens);
            Object.entries(themedStyles).forEach(function (_a) {
                var _b;
                var classIdent = _a[0], style = _a[1];
                var styleMapValue = styleMap_1.get(classIdent) || {};
                styleMap_1.set(classIdent, Object.assign({}, styleMapValue, (_b = {}, _b[themeRef] = style, _b)));
            });
        });
        Array.from(styleMap_1.entries()).forEach(function (_a) {
            var classIdent = _a[0], styles = _a[1];
            var classRef = webpackTreat_1.getIdentName(createLocalName(classIdent), webpackTreat_1.getNextScope());
            classRefs[classIdent] = createThemedCss(classRef, styles);
        });
    }
    else {
        var postCss = lodash_1.fromPairs(Object.entries(stylesheet).map(function (_a) {
            var classIdentifier = _a[0], style = _a[1];
            validator_1.validateStyle(style);
            var classRef = webpackTreat_1.getIdentName(createLocalName(classIdentifier), webpackTreat_1.getNextScope());
            classRefs[classIdentifier] = classRef;
            processSelectors_1.addLocalClassRef(classRef);
            processStyle(style);
            return [utils_1.convertToCssClass(classRef), style];
        }));
        webpackTreat_1.addLocalCss(postCss);
    }
    return classRefs;
}
exports.styleMap = styleMap;
function createTheme(tokens, localDebugName) {
    var theme = {
        themeRef: webpackTreat_1.getIdentName(localDebugName || 'theme', webpackTreat_1.getNextScope(), tokens),
        tokens: tokens,
    };
    webpackTreat_1.addTheme(theme);
    return theme.themeRef;
}
exports.createTheme = createTheme;
function globalStyle(selector, style) {
    var _a;
    if (processSelectors_1.isThemedSelector(selector)) {
        webpackTreat_1.getThemes().forEach(function (theme) {
            var _a;
            var themedSelector = processSelectors_1.interpolateSelector(selector, theme.themeRef);
            var themeStyle = typeof style === 'function' ? style(theme.tokens) : style;
            validator_1.validateGlobalStyle(themeStyle);
            webpackTreat_1.addThemedCss(theme.themeRef, (_a = {}, _a[themedSelector] = themeStyle, _a));
        });
    }
    else {
        var normalisedSelector = processSelectors_1.interpolateSelector(selector);
        if (typeof style === 'function') {
            throw Error(dedent_1.default(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          Unthemeable selector: ", "\n          \n          Global styles cannot be themed unless the selector references a themed class.\n          \n          For example, you could add a themed class to the start of your selector (e.g. ", ").\n          \n          Without a reference to a themed class, there is no way to selectively apply styles based on the current theme.\n        "], ["\n          Unthemeable selector: ", "\n          \n          Global styles cannot be themed unless the selector references a themed class.\n          \n          For example, you could add a themed class to the start of your selector (e.g. ", ").\n          \n          Without a reference to a themed class, there is no way to selectively apply styles based on the current theme.\n        "])), normalisedSelector, '`${themedClass} h1`'));
        }
        validator_1.validateGlobalStyle(style);
        processAnimations(style);
        webpackTreat_1.addLocalCss((_a = {}, _a[normalisedSelector] = style, _a));
    }
}
exports.globalStyle = globalStyle;
function styleTree(makeStyleTree) {
    var themedClassRefs = new Map();
    var assignedScopes = [];
    var getNodeScope = function (scopeIndex) {
        if (typeof assignedScopes[scopeIndex] !== 'number') {
            assignedScopes[scopeIndex] = webpackTreat_1.getNextScope();
        }
        return assignedScopes[scopeIndex];
    };
    var themedTrees = webpackTreat_1.getThemes().map(function (_a) {
        var tokens = _a.tokens, themeRef = _a.themeRef;
        var scopeIndex = 0;
        var makeStyle = function (style, localDebugName) {
            var _a;
            var localName = localDebugName || 'styleNode';
            var classRef = webpackTreat_1.getIdentName(localName, getNodeScope(scopeIndex++));
            var themedClassRefValue = themedClassRefs.get(classRef) || {};
            validator_1.validateStyle(style);
            themedClassRefs.set(classRef, Object.assign({}, themedClassRefValue, (_a = {}, _a[themeRef] = style, _a)));
            return utils_1.templateThemeClassRef(classRef);
        };
        return makeStyleTree(tokens, makeStyle);
    });
    var referenceTree = themedTrees[0], restTrees = themedTrees.slice(1);
    restTrees.forEach(function (tree) {
        if (!lodash_1.isEqual(tree, referenceTree)) {
            throw new Error(dedent_1.default(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n        Mismatching style trees.\n\n        All 'styleTree' functions must return the same structure for every theme.\n        \n        To avoid this error, ensure that object keys and array lengths do not depend on unique properties of each theme.\n        \n        Expected:\n        \n        ", "\n\n        Received:\n        \n        ", "\n      "], ["\n        Mismatching style trees.\n\n        All 'styleTree' functions must return the same structure for every theme.\n        \n        To avoid this error, ensure that object keys and array lengths do not depend on unique properties of each theme.\n        \n        Expected:\n        \n        ", "\n\n        Received:\n        \n        ", "\n      "])), javascript_stringify_1.stringify(referenceTree, null, 2), javascript_stringify_1.stringify(tree, null, 2)));
        }
    });
    Array.from(themedClassRefs.entries()).forEach(function (_a) {
        var classRef = _a[0], styles = _a[1];
        createThemedCss(classRef, styles);
    });
    return referenceTree;
}
exports.styleTree = styleTree;
var templateObject_1, templateObject_2;
